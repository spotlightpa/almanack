// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: image.sql

package db

import (
	"context"
)

const createImagePlaceholder = `-- name: CreateImagePlaceholder :execrows
INSERT INTO image ("path", "type")
  VALUES ($1, $2)
ON CONFLICT (path)
  DO NOTHING
`

type CreateImagePlaceholderParams struct {
	Path string `json:"path"`
	Type string `json:"type"`
}

func (q *Queries) CreateImagePlaceholder(ctx context.Context, arg CreateImagePlaceholderParams) (int64, error) {
	result, err := q.db.Exec(ctx, createImagePlaceholder, arg.Path, arg.Type)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getImageByMD5 = `-- name: GetImageByMD5 :one
SELECT
  id, path, type, description, credit, is_uploaded, created_at, updated_at, md5, bytes
FROM
  image
WHERE
  md5 = $1
ORDER BY
  created_at DESC
LIMIT 1
`

func (q *Queries) GetImageByMD5(ctx context.Context, md5 []byte) (Image, error) {
	row := q.db.QueryRow(ctx, getImageByMD5, md5)
	var i Image
	err := row.Scan(
		&i.ID,
		&i.Path,
		&i.Type,
		&i.Description,
		&i.Credit,
		&i.IsUploaded,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Md5,
		&i.Bytes,
	)
	return i, err
}

const getImageByPath = `-- name: GetImageByPath :one
SELECT
  id, path, type, description, credit, is_uploaded, created_at, updated_at, md5, bytes
FROM
  "image"
WHERE
  "path" = $1
`

func (q *Queries) GetImageByPath(ctx context.Context, path string) (Image, error) {
	row := q.db.QueryRow(ctx, getImageByPath, path)
	var i Image
	err := row.Scan(
		&i.ID,
		&i.Path,
		&i.Type,
		&i.Description,
		&i.Credit,
		&i.IsUploaded,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Md5,
		&i.Bytes,
	)
	return i, err
}

const getImageBySourceURL = `-- name: GetImageBySourceURL :one
SELECT
  image.id, image.path, image.type, image.description, image.credit, image.is_uploaded, image.created_at, image.updated_at, image.md5, image.bytes
FROM
  image
  LEFT JOIN image_source ON (image.id = image_source.image_id)
WHERE
  image_source.url = $1
`

func (q *Queries) GetImageBySourceURL(ctx context.Context, url string) (Image, error) {
	row := q.db.QueryRow(ctx, getImageBySourceURL, url)
	var i Image
	err := row.Scan(
		&i.ID,
		&i.Path,
		&i.Type,
		&i.Description,
		&i.Credit,
		&i.IsUploaded,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Md5,
		&i.Bytes,
	)
	return i, err
}

const getImageTypeForExtension = `-- name: GetImageTypeForExtension :one
SELECT
  name, mime, extensions
FROM
  image_type
WHERE
  $1::text = ANY (extensions)
`

func (q *Queries) GetImageTypeForExtension(ctx context.Context, extension string) (ImageType, error) {
	row := q.db.QueryRow(ctx, getImageTypeForExtension, extension)
	var i ImageType
	err := row.Scan(&i.Name, &i.Mime, &i.Extensions)
	return i, err
}

const listImageWhereNotUploaded = `-- name: ListImageWhereNotUploaded :many
SELECT
  "path",
  "url"::text
FROM
  image
  LEFT JOIN image_source ON (image.id = image_source.image_id)
WHERE
  is_uploaded = FALSE
  AND url IS NOT NULL
`

type ListImageWhereNotUploadedRow struct {
	Path string `json:"path"`
	URL  string `json:"url"`
}

// ListImageWhereNotUploaded has no limit
// because we want them all uploaded,
// but revisit if queue gets too long.
func (q *Queries) ListImageWhereNotUploaded(ctx context.Context) ([]ListImageWhereNotUploadedRow, error) {
	rows, err := q.db.Query(ctx, listImageWhereNotUploaded)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListImageWhereNotUploadedRow
	for rows.Next() {
		var i ListImageWhereNotUploadedRow
		if err := rows.Scan(&i.Path, &i.URL); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listImages = `-- name: ListImages :many
SELECT
  id, path, type, description, credit, is_uploaded, created_at, updated_at, md5, bytes
FROM
  image
WHERE
  is_uploaded = TRUE
ORDER BY
  updated_at DESC
LIMIT $1 OFFSET $2
`

type ListImagesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListImages(ctx context.Context, arg ListImagesParams) ([]Image, error) {
	rows, err := q.db.Query(ctx, listImages, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Image
	for rows.Next() {
		var i Image
		if err := rows.Scan(
			&i.ID,
			&i.Path,
			&i.Type,
			&i.Description,
			&i.Credit,
			&i.IsUploaded,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Md5,
			&i.Bytes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listImagesWhereNoMD5 = `-- name: ListImagesWhereNoMD5 :many
SELECT
  id, path, type, description, credit, is_uploaded, created_at, updated_at, md5, bytes
FROM
  image
WHERE
  md5 = ''
  AND is_uploaded
ORDER BY
  created_at ASC
LIMIT $1
`

func (q *Queries) ListImagesWhereNoMD5(ctx context.Context, limit int32) ([]Image, error) {
	rows, err := q.db.Query(ctx, listImagesWhereNoMD5, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Image
	for rows.Next() {
		var i Image
		if err := rows.Scan(
			&i.ID,
			&i.Path,
			&i.Type,
			&i.Description,
			&i.Credit,
			&i.IsUploaded,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Md5,
			&i.Bytes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateImage = `-- name: UpdateImage :one
UPDATE
  image
SET
  credit = CASE WHEN $1::boolean THEN
    $2
  ELSE
    credit
  END,
  description = CASE WHEN $3::boolean THEN
    $4
  ELSE
    description
  END,
  is_uploaded = TRUE
WHERE
  path = $5
RETURNING
  id, path, type, description, credit, is_uploaded, created_at, updated_at, md5, bytes
`

type UpdateImageParams struct {
	SetCredit      bool   `json:"set_credit"`
	Credit         string `json:"credit"`
	SetDescription bool   `json:"set_description"`
	Description    string `json:"description"`
	Path           string `json:"path"`
}

func (q *Queries) UpdateImage(ctx context.Context, arg UpdateImageParams) (Image, error) {
	row := q.db.QueryRow(ctx, updateImage,
		arg.SetCredit,
		arg.Credit,
		arg.SetDescription,
		arg.Description,
		arg.Path,
	)
	var i Image
	err := row.Scan(
		&i.ID,
		&i.Path,
		&i.Type,
		&i.Description,
		&i.Credit,
		&i.IsUploaded,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Md5,
		&i.Bytes,
	)
	return i, err
}

const updateImageMD5Size = `-- name: UpdateImageMD5Size :one
UPDATE
  image
SET
  md5 = $1,
  bytes = $2
WHERE
  id = $3
RETURNING
  id, path, type, description, credit, is_uploaded, created_at, updated_at, md5, bytes
`

type UpdateImageMD5SizeParams struct {
	Md5   []byte `json:"md5"`
	Bytes int64  `json:"bytes"`
	ID    int64  `json:"id"`
}

func (q *Queries) UpdateImageMD5Size(ctx context.Context, arg UpdateImageMD5SizeParams) (Image, error) {
	row := q.db.QueryRow(ctx, updateImageMD5Size, arg.Md5, arg.Bytes, arg.ID)
	var i Image
	err := row.Scan(
		&i.ID,
		&i.Path,
		&i.Type,
		&i.Description,
		&i.Credit,
		&i.IsUploaded,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Md5,
		&i.Bytes,
	)
	return i, err
}

const upsertImage = `-- name: UpsertImage :one
INSERT INTO image ("path", "type", "description", "credit", "is_uploaded")
  VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (path)
  DO UPDATE SET
    credit = CASE WHEN image.credit = '' THEN
      excluded.credit
    ELSE
      image.credit
    END, description = CASE WHEN image.description = '' THEN
      excluded.description
    ELSE
      image.description
    END
  RETURNING
    id, path, type, description, credit, is_uploaded, created_at, updated_at, md5, bytes
`

type UpsertImageParams struct {
	Path        string `json:"path"`
	Type        string `json:"type"`
	Description string `json:"description"`
	Credit      string `json:"credit"`
	IsUploaded  bool   `json:"is_uploaded"`
}

func (q *Queries) UpsertImage(ctx context.Context, arg UpsertImageParams) (Image, error) {
	row := q.db.QueryRow(ctx, upsertImage,
		arg.Path,
		arg.Type,
		arg.Description,
		arg.Credit,
		arg.IsUploaded,
	)
	var i Image
	err := row.Scan(
		&i.ID,
		&i.Path,
		&i.Type,
		&i.Description,
		&i.Credit,
		&i.IsUploaded,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Md5,
		&i.Bytes,
	)
	return i, err
}

const upsertImageSource = `-- name: UpsertImageSource :exec
INSERT INTO image_source (image_id, url)
  VALUES ($1, $2)
ON CONFLICT (url)
  DO NOTHING
`

type UpsertImageSourceParams struct {
	ImageID int64  `json:"image_id"`
	URL     string `json:"url"`
}

func (q *Queries) UpsertImageSource(ctx context.Context, arg UpsertImageSourceParams) error {
	_, err := q.db.Exec(ctx, upsertImageSource, arg.ImageID, arg.URL)
	return err
}
