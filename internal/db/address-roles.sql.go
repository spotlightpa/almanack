// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.0
// source: address-roles.sql

package db

import (
	"context"
)

const getRolesForAddress = `-- name: GetRolesForAddress :one
SELECT
  roles
FROM
  address_roles
WHERE
  "email_address" ILIKE $1
`

func (q *Queries) GetRolesForAddress(ctx context.Context, emailAddress string) ([]string, error) {
	row := q.db.QueryRow(ctx, getRolesForAddress, emailAddress)
	var roles []string
	err := row.Scan(&roles)
	return roles, err
}

const listAddressesWithRole = `-- name: ListAddressesWithRole :many
SELECT
  "email_address"
FROM
  "address_roles"
WHERE
  "roles" @> ARRAY[$1::text]
ORDER BY
  "email_address" ASC
`

func (q *Queries) ListAddressesWithRole(ctx context.Context, role string) ([]string, error) {
	rows, err := q.db.Query(ctx, listAddressesWithRole, role)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var email_address string
		if err := rows.Scan(&email_address); err != nil {
			return nil, err
		}
		items = append(items, email_address)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertRolesForAddress = `-- name: UpsertRolesForAddress :one
INSERT INTO address_roles ("email_address", roles)
  VALUES ($1, $2)
ON CONFLICT (lower("email_address"))
  DO UPDATE SET
    roles = $2
  RETURNING
    id, email_address, roles, created_at, updated_at
`

type UpsertRolesForAddressParams struct {
	EmailAddress string   `json:"email_address"`
	Roles        []string `json:"roles"`
}

func (q *Queries) UpsertRolesForAddress(ctx context.Context, arg UpsertRolesForAddressParams) (AddressRole, error) {
	row := q.db.QueryRow(ctx, upsertRolesForAddress, arg.EmailAddress, arg.Roles)
	var i AddressRole
	err := row.Scan(
		&i.ID,
		&i.EmailAddress,
		&i.Roles,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
