// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: news-feed.sql

package db

import (
	"context"
)

const listAppleNewsChannels = `-- name: ListAppleNewsChannels :many
SELECT
  id, name, apple_channel_id, key, secret, source_feed_url, last_synced_at, created_at, updated_at
FROM
  apple_news_channel
ORDER BY
  name
`

func (q *Queries) ListAppleNewsChannels(ctx context.Context) ([]AppleNewsChannel, error) {
	rows, err := q.db.Query(ctx, listAppleNewsChannels)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppleNewsChannel
	for rows.Next() {
		var i AppleNewsChannel
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.AppleChannelID,
			&i.Key,
			&i.Secret,
			&i.SourceFeedUrl,
			&i.LastSyncedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNewsFeedUpdates = `-- name: ListNewsFeedUpdates :many
SELECT
  id, external_id, author, authors, blurb, category, content_html, external_updated_at, external_published_at, image, image_credit, image_description, language, title, url, uploaded_at, apple_id, apple_share_url, created_at, updated_at, source_feed_url
FROM
  news_feed_item
WHERE
  "source_feed_url" = $1
  AND "uploaded_at" IS NULL
`

func (q *Queries) ListNewsFeedUpdates(ctx context.Context, sourceFeedUrl string) ([]NewsFeedItem, error) {
	rows, err := q.db.Query(ctx, listNewsFeedUpdates, sourceFeedUrl)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NewsFeedItem
	for rows.Next() {
		var i NewsFeedItem
		if err := rows.Scan(
			&i.ID,
			&i.ExternalID,
			&i.Author,
			&i.Authors,
			&i.Blurb,
			&i.Category,
			&i.ContentHtml,
			&i.ExternalUpdatedAt,
			&i.ExternalPublishedAt,
			&i.Image,
			&i.ImageCredit,
			&i.ImageDescription,
			&i.Language,
			&i.Title,
			&i.URL,
			&i.UploadedAt,
			&i.AppleID,
			&i.AppleShareUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SourceFeedUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFeedAppleID = `-- name: UpdateFeedAppleID :one
UPDATE
  news_feed_item
SET
  "apple_id" = $1,
  "apple_share_url" = $2,
  "uploaded_at" = CURRENT_TIMESTAMP,
  "updated_at" = CURRENT_TIMESTAMP
WHERE
  "id" = $3
RETURNING
  id, external_id, author, authors, blurb, category, content_html, external_updated_at, external_published_at, image, image_credit, image_description, language, title, url, uploaded_at, apple_id, apple_share_url, created_at, updated_at, source_feed_url
`

type UpdateFeedAppleIDParams struct {
	AppleID       string `json:"apple_id"`
	AppleShareUrl string `json:"apple_share_url"`
	ID            int64  `json:"id"`
}

func (q *Queries) UpdateFeedAppleID(ctx context.Context, arg UpdateFeedAppleIDParams) (NewsFeedItem, error) {
	row := q.db.QueryRow(ctx, updateFeedAppleID, arg.AppleID, arg.AppleShareUrl, arg.ID)
	var i NewsFeedItem
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Author,
		&i.Authors,
		&i.Blurb,
		&i.Category,
		&i.ContentHtml,
		&i.ExternalUpdatedAt,
		&i.ExternalPublishedAt,
		&i.Image,
		&i.ImageCredit,
		&i.ImageDescription,
		&i.Language,
		&i.Title,
		&i.URL,
		&i.UploadedAt,
		&i.AppleID,
		&i.AppleShareUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SourceFeedUrl,
	)
	return i, err
}

const updateFeedUploaded = `-- name: UpdateFeedUploaded :one
UPDATE
  news_feed_item
SET
  "uploaded_at" = CURRENT_TIMESTAMP,
  "updated_at" = CURRENT_TIMESTAMP
WHERE
  "id" = $1
RETURNING
  id, external_id, author, authors, blurb, category, content_html, external_updated_at, external_published_at, image, image_credit, image_description, language, title, url, uploaded_at, apple_id, apple_share_url, created_at, updated_at, source_feed_url
`

func (q *Queries) UpdateFeedUploaded(ctx context.Context, id int64) (NewsFeedItem, error) {
	row := q.db.QueryRow(ctx, updateFeedUploaded, id)
	var i NewsFeedItem
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Author,
		&i.Authors,
		&i.Blurb,
		&i.Category,
		&i.ContentHtml,
		&i.ExternalUpdatedAt,
		&i.ExternalPublishedAt,
		&i.Image,
		&i.ImageCredit,
		&i.ImageDescription,
		&i.Language,
		&i.Title,
		&i.URL,
		&i.UploadedAt,
		&i.AppleID,
		&i.AppleShareUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SourceFeedUrl,
	)
	return i, err
}

const upsertNewsFeedArchives = `-- name: UpsertNewsFeedArchives :execrows
WITH raw_json AS (
  SELECT
    jsonb_array_elements($2::jsonb) AS data
),
feed_items AS (
  SELECT
    data ->> 'id' AS external_id,
    data ->> 'author' AS author,
    CASE WHEN jsonb_typeof(data -> 'authors') = 'array' THEN
      ARRAY (
        SELECT
          jsonb_array_elements_text(data -> 'authors'))
    ELSE
      ARRAY[]::text[]
    END AS authors,
    data ->> 'blurb' AS blurb,
    data ->> 'category' AS category,
    data ->> 'content_html' AS content_html,
    iso_to_timestamptz (data ->> 'date_modified')::timestamptz AS external_updated_at,
    iso_to_timestamptz (data ->> 'date_published')::timestamptz AS external_published_at,
    data ->> 'image' AS image,
    data ->> 'image_credit' AS image_credit,
    data ->> 'image_description' AS image_description,
    data ->> 'language' AS "language",
    data ->> 'title' AS title,
    data ->> 'url' AS url
  FROM
    raw_json)
INSERT INTO news_feed_item ("source_feed_url", "external_id", "author",
  "authors", "blurb", "category", "content_html", "external_updated_at",
  "external_published_at", "image", "image_credit", "image_description",
  "language", "title", "url")
SELECT
  $1,
  "external_id",
  COALESCE("author", ''),
  "authors",
  COALESCE("blurb", ''),
  COALESCE("category", ''),
  COALESCE("content_html", ''),
  "external_updated_at",
  "external_published_at",
  COALESCE("image", ''),
  COALESCE("image_credit", ''),
  COALESCE("image_description", ''),
  COALESCE("language", ''),
  COALESCE("title", ''),
  COALESCE("url", '')
FROM
  feed_items
ON CONFLICT ("source_feed_url",
  "external_id")
  DO UPDATE SET
    "author" = EXCLUDED.author,
    "authors" = EXCLUDED.authors,
    "category" = EXCLUDED.category,
    "content_html" = EXCLUDED.content_html,
    "external_updated_at" = EXCLUDED.external_updated_at,
    "external_published_at" = EXCLUDED.external_published_at,
    "image" = EXCLUDED.image,
    "image_credit" = EXCLUDED.image_credit,
    "image_description" = EXCLUDED.image_description,
    "language" = EXCLUDED.language,
    "title" = EXCLUDED.title,
    "url" = EXCLUDED.url,
    "uploaded_at" = CASE WHEN news_feed_item.external_updated_at <>
      EXCLUDED.external_updated_at THEN
      NULL
    ELSE
      news_feed_item.uploaded_at
    END,
    "updated_at" = CURRENT_TIMESTAMP
`

type UpsertNewsFeedArchivesParams struct {
	SourceFeedUrl string `json:"source_feed_url"`
	Data          []byte `json:"data"`
}

func (q *Queries) UpsertNewsFeedArchives(ctx context.Context, arg UpsertNewsFeedArchivesParams) (int64, error) {
	result, err := q.db.Exec(ctx, upsertNewsFeedArchives, arg.SourceFeedUrl, arg.Data)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
