// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: file.sql

package db

import (
	"context"
)

const createFilePlaceholder = `-- name: CreateFilePlaceholder :execrows
INSERT INTO file ("filename", "url", "mime_type")
  VALUES ($1, $2, $3)
ON CONFLICT (url)
  DO NOTHING
`

type CreateFilePlaceholderParams struct {
	Filename string `json:"filename"`
	URL      string `json:"url"`
	Type     string `json:"type"`
}

func (q *Queries) CreateFilePlaceholder(ctx context.Context, arg CreateFilePlaceholderParams) (int64, error) {
	result, err := q.db.Exec(ctx, createFilePlaceholder, arg.Filename, arg.URL, arg.Type)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const listFiles = `-- name: ListFiles :many
SELECT
  id, url, filename, mime_type, description, is_uploaded, created_at, updated_at, md5, bytes, deleted_at
FROM
  file
WHERE
  is_uploaded = TRUE
  AND deleted_at IS NULL
ORDER BY
  created_at DESC
LIMIT $1 OFFSET $2
`

type ListFilesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListFiles(ctx context.Context, arg ListFilesParams) ([]File, error) {
	rows, err := q.db.Query(ctx, listFiles, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []File
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.URL,
			&i.Filename,
			&i.MimeType,
			&i.Description,
			&i.IsUploaded,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MD5,
			&i.Bytes,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFilesWhereNoMD5 = `-- name: ListFilesWhereNoMD5 :many
SELECT
  id, url, filename, mime_type, description, is_uploaded, created_at, updated_at, md5, bytes, deleted_at
FROM
  file
WHERE
  md5 = ''
  AND is_uploaded
  AND deleted_at IS NULL
ORDER BY
  created_at ASC
LIMIT $1
`

func (q *Queries) ListFilesWhereNoMD5(ctx context.Context, limit int32) ([]File, error) {
	rows, err := q.db.Query(ctx, listFilesWhereNoMD5, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []File
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.URL,
			&i.Filename,
			&i.MimeType,
			&i.Description,
			&i.IsUploaded,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MD5,
			&i.Bytes,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFile = `-- name: UpdateFile :one
UPDATE
  file
SET
  description = CASE WHEN $1::boolean THEN
    $2
  ELSE
    description
  END,
  is_uploaded = TRUE
WHERE
  url = $3
RETURNING
  id, url, filename, mime_type, description, is_uploaded, created_at, updated_at, md5, bytes, deleted_at
`

type UpdateFileParams struct {
	SetDescription bool   `json:"set_description"`
	Description    string `json:"description"`
	URL            string `json:"url"`
}

func (q *Queries) UpdateFile(ctx context.Context, arg UpdateFileParams) (File, error) {
	row := q.db.QueryRow(ctx, updateFile, arg.SetDescription, arg.Description, arg.URL)
	var i File
	err := row.Scan(
		&i.ID,
		&i.URL,
		&i.Filename,
		&i.MimeType,
		&i.Description,
		&i.IsUploaded,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MD5,
		&i.Bytes,
		&i.DeletedAt,
	)
	return i, err
}

const updateFileMD5Size = `-- name: UpdateFileMD5Size :one
UPDATE
  file
SET
  md5 = $1,
  bytes = $2
WHERE
  id = $3
RETURNING
  id, url, filename, mime_type, description, is_uploaded, created_at, updated_at, md5, bytes, deleted_at
`

type UpdateFileMD5SizeParams struct {
	MD5   []byte `json:"md5"`
	Bytes int64  `json:"bytes"`
	ID    int64  `json:"id"`
}

func (q *Queries) UpdateFileMD5Size(ctx context.Context, arg UpdateFileMD5SizeParams) (File, error) {
	row := q.db.QueryRow(ctx, updateFileMD5Size, arg.MD5, arg.Bytes, arg.ID)
	var i File
	err := row.Scan(
		&i.ID,
		&i.URL,
		&i.Filename,
		&i.MimeType,
		&i.Description,
		&i.IsUploaded,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MD5,
		&i.Bytes,
		&i.DeletedAt,
	)
	return i, err
}
