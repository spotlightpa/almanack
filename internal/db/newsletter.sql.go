// Code generated by sqlc. DO NOT EDIT.
// source: newsletter.sql

package db

import (
	"context"
	"encoding/json"
)

const listNewsletters = `-- name: ListNewsletters :many
SELECT
  subject, archive_url, published_at, type, created_at, updated_at, description, blurb, spotlightpa_path
FROM
  newsletter
WHERE
  "type" = $1
ORDER BY
  published_at DESC
LIMIT $2 OFFSET $3
`

type ListNewslettersParams struct {
	Type   string `json:"type"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListNewsletters(ctx context.Context, arg ListNewslettersParams) ([]Newsletter, error) {
	rows, err := q.db.QueryContext(ctx, listNewsletters, arg.Type, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Newsletter
	for rows.Next() {
		var i Newsletter
		if err := rows.Scan(
			&i.Subject,
			&i.ArchiveURL,
			&i.PublishedAt,
			&i.Type,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Description,
			&i.Blurb,
			&i.SpotlightPAPath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateNewsletterArchives = `-- name: UpdateNewsletterArchives :execrows
WITH raw_json AS (
  SELECT
    jsonb_array_elements($2::jsonb) AS data
),
campaign AS (
  SELECT
    data ->> 'subject' AS subject,
    data ->> 'blurb' AS blurb,
    data ->> 'description' AS description,
    data ->> 'archive_url' AS archive_url,
    to_timestamp(data ->> 'published_at'::text,
      -- ISO date
      'YYYY-MM-DD"T"HH24:MI:SS"Z"')::timestamp WITH time zone AS published_at
  FROM
    raw_json)
  INSERT INTO newsletter ("subject", "blurb", "description", "archive_url",
    "published_at", "type")
  SELECT
    subject,
    blurb,
    description,
    archive_url,
    published_at,
    $1
  FROM
    campaign
  ON CONFLICT
    DO NOTHING
`

type UpdateNewsletterArchivesParams struct {
	Type string          `json:"type"`
	Data json.RawMessage `json:"data"`
}

func (q *Queries) UpdateNewsletterArchives(ctx context.Context, arg UpdateNewsletterArchivesParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateNewsletterArchives, arg.Type, arg.Data)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
